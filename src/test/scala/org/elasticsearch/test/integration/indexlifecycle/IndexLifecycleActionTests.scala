package org.elasticsearch.test.integration.indexlifecycle

import org.elasticsearch.cluster.routing.ShardRoutingState._
import org.elasticsearch.common.settings.ImmutableSettings._
import org.elasticsearch.action.admin.cluster.health._
import org.elasticsearch.cluster._
import org.elasticsearch.node.internal._
import com.traackr.scalastic.elasticsearch._

@org.junit.runner.RunWith(classOf[org.scalatest.junit.JUnitRunner])
class IndexLifecycleActionTests extends MultiNodesBasedTests {

  override def afterEach = closeAllNodes()

  test("testIndexLifecycleActionsWith11Shards1Backup") {
    val settings = settingsBuilder
      .put("index.number_of_shards", 11)
      .put("index.number_of_replicas", 1)
      .put("cluster.routing.schedule", "20ms")
      .build()
    //logger.info("Starting sever1")
    startNode("server1", settings)
    val clusterService1 = node("server1").asInstanceOf[InternalNode].injector()
      .getInstance(classOf[ClusterService])
    val createIndexResponse = indexer("server1").createIndex(indexName)
    createIndexResponse.acknowledged() should be === (true)
    var clusterHealth = indexer("server1").waitForYellowStatus()
    clusterHealth.timedOut() should be === (false)
    clusterHealth.status() should be === (ClusterHealthStatus.YELLOW)
    Thread.sleep(200)
    var clusterState1 = clusterService1.state()
    var routingNodeEntry1 = clusterState1.readOnlyRoutingNodes().nodesToShards()
      .get(clusterState1.nodes().localNodeId())
    routingNodeEntry1.numberOfShardsWithState(STARTED) should be === (11)
    clusterState1 = indexer("server1").state().state()
    routingNodeEntry1 = clusterState1.readOnlyRoutingNodes().nodesToShards()
      .get(clusterState1.nodes().localNodeId())
    routingNodeEntry1.numberOfShardsWithState(STARTED) should be === (11)
    //logger.info("Starting server2")
    startNode("server2", settings)
    val clusterService2 = node("server2").asInstanceOf[InternalNode].injector()
      .getInstance(classOf[ClusterService])
    clusterHealth = indexer("server1").health_prepare().setWaitForGreenStatus().setWaitForNodes("2").execute.actionGet
    clusterHealth.timedOut() should be === (false)
    clusterHealth.status() should be === (ClusterHealthStatus.GREEN)
    Thread.sleep(200)
    clusterState1 = clusterService1.state()
    routingNodeEntry1 = clusterState1.readOnlyRoutingNodes().nodesToShards()
      .get(clusterState1.nodes().localNodeId())
    routingNodeEntry1.numberOfShardsWithState(STARTED) should be === (11)
    var clusterState2 = clusterService2.state()
    var routingNodeEntry2 = clusterState2.readOnlyRoutingNodes().nodesToShards()
      .get(clusterState2.nodes().localNodeId())
    routingNodeEntry2.numberOfShardsWithState(STARTED) should be === (11)
    //logger.info("Starting server3")
    startNode("server3", settings)
    Thread.sleep(200)
    val clusterService3 = node("server3").asInstanceOf[InternalNode].injector()
      .getInstance(classOf[ClusterService])
    clusterHealth = indexer("server1").health_prepare().setWaitForGreenStatus().setWaitForNodes("3").setWaitForRelocatingShards(0).execute.actionGet
    clusterHealth.timedOut() should be === (false)
    clusterHealth.status() should be === (ClusterHealthStatus.GREEN)
    clusterHealth.relocatingShards() should be === (0)
    clusterHealth.activeShards() should be === (22)
    clusterHealth.activePrimaryShards() should be === (11)
    Thread.sleep(200)
    clusterState1 = clusterService1.state()
    routingNodeEntry1 = clusterState1.readOnlyRoutingNodes().nodesToShards()
      .get(clusterState1.nodes().localNodeId())
    //    routingNodeEntry1.numberOfShardsWithState(STARTED), anyOf(equalTo(7) should be === (8))
    clusterState2 = clusterService2.state()
    routingNodeEntry2 = clusterState2.readOnlyRoutingNodes().nodesToShards()
      .get(clusterState2.nodes().localNodeId())
    //    routingNodeEntry2.numberOfShardsWithState(STARTED), anyOf(equalTo(7) should be === (8))
    var clusterState3 = clusterService3.state()
    var routingNodeEntry3 = clusterState3.readOnlyRoutingNodes().nodesToShards()
      .get(clusterState3.nodes().localNodeId())
    routingNodeEntry3.numberOfShardsWithState(STARTED) should be === (7)
    routingNodeEntry1.numberOfShardsWithState(STARTED) + routingNodeEntry2.numberOfShardsWithState(STARTED) + routingNodeEntry3.numberOfShardsWithState(STARTED) should be === (22)
    closeNode("server1")
    clusterHealth = indexer("server3").health_prepare().setWaitForGreenStatus().setWaitForNodes("2").setWaitForRelocatingShards(0).execute.actionGet
    clusterHealth.timedOut() should be === (false)
    clusterHealth.status() should be === (ClusterHealthStatus.GREEN)
    clusterHealth.relocatingShards() should be === (0)
    clusterHealth.activeShards() should be === (22)
    clusterHealth.activePrimaryShards() should be === (11)
    Thread.sleep(200)
    clusterState2 = clusterService2.state()
    routingNodeEntry2 = clusterState2.readOnlyRoutingNodes().nodesToShards()
      .get(clusterState2.nodes().localNodeId())
    routingNodeEntry2.numberOfShardsWithState(STARTED) should be === (11)
    clusterState3 = clusterService3.state()
    routingNodeEntry3 = clusterState3.readOnlyRoutingNodes().nodesToShards()
      .get(clusterState3.nodes().localNodeId())
    routingNodeEntry3.numberOfShardsWithState(STARTED) should be === (11)
    routingNodeEntry2.numberOfShardsWithState(STARTED) + routingNodeEntry3.numberOfShardsWithState(STARTED) should be === (22)
    val deleteIndexResponse = indexer("server2").deleteIndex(Seq(indexName))
    deleteIndexResponse.acknowledged() should be === (true)
    Thread.sleep(500)
    clusterState2 = clusterService2.state()
    routingNodeEntry2 = clusterState2.readOnlyRoutingNodes().nodesToShards()
      .get(clusterState2.nodes().localNodeId())
    routingNodeEntry2 should be(null)
    clusterState3 = clusterService3.state()
    routingNodeEntry3 = clusterState3.readOnlyRoutingNodes().nodesToShards()
      .get(clusterState3.nodes().localNodeId())
    routingNodeEntry3 should be(null)
  }

  test("testIndexLifecycleActionsWith11Shards0Backup") {
    val settings = settingsBuilder
      .put("index.number_of_shards", 11)
      .put("index.number_of_replicas", 0)
      .put("cluster.routing.schedule", "20ms")
      .build()
    //logger.info("Starting server1")
    startNode("server1", settings)
    val clusterService1 = node("server1").asInstanceOf[InternalNode].injector()
      .getInstance(classOf[ClusterService])
    val createIndexResponse = indexer("server1").createIndex(indexName)
    createIndexResponse.acknowledged() should be === (true)
    var clusterHealth = indexer("server1").waitForGreenStatus()
    clusterHealth.timedOut() should be === (false)
    clusterHealth.status() should be === (ClusterHealthStatus.GREEN)
    clusterHealth.relocatingShards() should be === (0)
    clusterHealth.activeShards() should be === (11)
    clusterHealth.activePrimaryShards() should be === (11)
    var clusterState1 = clusterService1.state()
    var routingNodeEntry1 = clusterState1.readOnlyRoutingNodes().nodesToShards()
      .get(clusterState1.nodes().localNodeId())
    routingNodeEntry1.numberOfShardsWithState(STARTED) should be === (11)
    //logger.info("Starting server2")
    startNode("server2", settings)
    Thread.sleep(200)
    clusterHealth = indexer("server1").health_prepare().setWaitForGreenStatus().setWaitForRelocatingShards(0).setWaitForNodes("2").execute.actionGet
    clusterHealth.timedOut() should be === (false)
    clusterHealth.status() should be === (ClusterHealthStatus.GREEN)
    clusterHealth.relocatingShards() should be === (0)
    clusterHealth.activeShards() should be === (11)
    clusterHealth.activePrimaryShards() should be === (11)
    Thread.sleep(200)
    val clusterService2 = node("server2").asInstanceOf[InternalNode].injector()
      .getInstance(classOf[ClusterService])
    clusterState1 = clusterService1.state()
    routingNodeEntry1 = clusterState1.readOnlyRoutingNodes().nodesToShards().get(clusterState1.nodes().localNodeId())
    Set(5, 6) should contain(routingNodeEntry1.numberOfShardsWithState(STARTED))
    var clusterState2 = clusterService2.state()
    var routingNodeEntry2 = clusterState2.readOnlyRoutingNodes().nodesToShards().get(clusterState2.nodes().localNodeId())
    Set(5, 6) should contain(routingNodeEntry2.numberOfShardsWithState(STARTED))
    //logger.info("Starting server3")
    startNode("server3")
    Thread.sleep(200)
    val clusterService3 = node("server3").asInstanceOf[InternalNode].injector()
      .getInstance(classOf[ClusterService])
    clusterHealth = indexer("server1").health_prepare().setWaitForGreenStatus().setWaitForRelocatingShards(0).setWaitForNodes("3").execute.actionGet
    clusterHealth.timedOut() should be === (false)
    clusterHealth.status() should be === (ClusterHealthStatus.GREEN)
    clusterHealth.relocatingShards() should be === (0)
    clusterHealth.activeShards() should be === (11)
    clusterHealth.activePrimaryShards() should be === (11)
    Thread.sleep(200)
    clusterState1 = clusterService1.state()
    routingNodeEntry1 = clusterState1.readOnlyRoutingNodes().nodesToShards().get(clusterState1.nodes().localNodeId())
    Set(3, 4, 5) should contain(routingNodeEntry1.numberOfShardsWithState(STARTED))
    clusterState2 = clusterService2.state()
    routingNodeEntry2 = clusterState2.readOnlyRoutingNodes().nodesToShards().get(clusterState2.nodes().localNodeId())
    Set(3, 4, 5) should contain(routingNodeEntry2.numberOfShardsWithState(STARTED))
    var clusterState3 = clusterService3.state()
    var routingNodeEntry3 = clusterState3.readOnlyRoutingNodes().nodesToShards()
      .get(clusterState3.nodes().localNodeId())
    routingNodeEntry3.numberOfShardsWithState(STARTED) should be === (3)
    routingNodeEntry1.numberOfShardsWithState(STARTED) + routingNodeEntry2.numberOfShardsWithState(STARTED) + routingNodeEntry3.numberOfShardsWithState(STARTED) should be === (11)
    closeNode("server1")
    clusterHealth = indexer("server3").health_prepare().setWaitForGreenStatus().setWaitForNodes("2").setWaitForRelocatingShards(0).execute.actionGet
    clusterHealth.timedOut() should be === (false)
    clusterHealth.status() should be === (ClusterHealthStatus.GREEN)
    clusterHealth.relocatingShards() should be === (0)
    clusterHealth.activeShards() should be === (11)
    clusterHealth.activePrimaryShards() should be === (11)
    Thread.sleep(200)
    clusterState2 = clusterService2.state()
    routingNodeEntry2 = clusterState2.readOnlyRoutingNodes().nodesToShards().get(clusterState2.nodes().localNodeId())
    Set(5, 6) should contain(routingNodeEntry2.numberOfShardsWithState(STARTED))
    clusterState3 = clusterService3.state()
    routingNodeEntry3 = clusterState3.readOnlyRoutingNodes().nodesToShards().get(clusterState3.nodes().localNodeId())
    Set(5, 6) should contain(routingNodeEntry3.numberOfShardsWithState(STARTED))
    routingNodeEntry2.numberOfShardsWithState(STARTED) + routingNodeEntry3.numberOfShardsWithState(STARTED) should be === (11)
    val deleteIndexResponse = indexer("server2").deleteIndex(Seq(indexName))
    deleteIndexResponse.acknowledged() should be === (true)
    Thread.sleep(500)
    clusterState2 = clusterService2.state()
    routingNodeEntry2 = clusterState2.readOnlyRoutingNodes().nodesToShards().get(clusterState2.nodes().localNodeId())
    routingNodeEntry2 should be(null)
    clusterState3 = clusterService3.state()
    routingNodeEntry3 = clusterState3.readOnlyRoutingNodes().nodesToShards().get(clusterState3.nodes().localNodeId())
    routingNodeEntry3 should be(null)
  }
}
