package org.elasticsearch.test.integration.indexlifecycle

import org.elasticsearch.cluster.routing.ShardRoutingState._
import org.elasticsearch.common.settings.ImmutableSettings._
import org.elasticsearch.action.admin.cluster.health._
import org.elasticsearch.cluster._
import org.elasticsearch.node.internal._
import scalastic.elasticsearch._

@org.junit.runner.RunWith(classOf[org.scalatest.junit.JUnitRunner])
class IndexLifecycleActionTests extends MultiNodesBasedTests {

  override def afterEach() { closeAllNodes() }

  //fixme
  ignore("testIndexLifecycleActionsWith11Shards1Backup") {
    val settings = settingsBuilder
      .put("index.number_of_shards", 11)
      .put("index.number_of_replicas", 1)
      .put("cluster.routing.schedule", "20ms")
      .build()
    //logger.info("Starting sever1")
    startNode("server1", settings)
    val clusterService1 = node("server1").asInstanceOf[InternalNode].injector()
      .getInstance(classOf[ClusterService])
    val createIndexResponse = indexer("server1").createIndex(indexName)
    createIndexResponse.isAcknowledged should equal (true)
    var clusterHealth = indexer("server1").waitForYellowStatus()
    clusterHealth.isTimedOut should equal (false)
    clusterHealth.getStatus should equal (ClusterHealthStatus.YELLOW)
    Thread.sleep(200)
    var clusterState1 = clusterService1.state()
    var routingNodeEntry1 = clusterState1.routingTable.indicesRouting.get(clusterState1.nodes().localNodeId())
    routingNodeEntry1.shardsWithState(STARTED).size should equal (11)
    clusterState1 = indexer("server1").state().getState
    routingNodeEntry1 = clusterState1.routingTable.indicesRouting.get(clusterState1.nodes().localNodeId())
    routingNodeEntry1.shardsWithState(STARTED).size should equal (11)
    //logger.info("Starting server2")
    startNode("server2", settings)
    val clusterService2 = node("server2").asInstanceOf[InternalNode].injector()
      .getInstance(classOf[ClusterService])
    clusterHealth = indexer("server1").health_prepare().setWaitForGreenStatus().setWaitForNodes("2").execute.actionGet
    clusterHealth.isTimedOut should equal (false)
    clusterHealth.getStatus should equal (ClusterHealthStatus.GREEN)
    Thread.sleep(200)
    clusterState1 = clusterService1.state()
    routingNodeEntry1 = clusterState1.routingTable.indicesRouting.get(clusterState1.nodes().localNodeId())
    routingNodeEntry1.shardsWithState(STARTED).size should equal (11)
    var clusterState2 = clusterService2.state()
    var routingNodeEntry2 = clusterState2.routingTable.indicesRouting.get(clusterState2.nodes().localNodeId())
    routingNodeEntry2.shardsWithState(STARTED).size should equal (11)
    //logger.info("Starting server3")
    startNode("server3", settings)
    Thread.sleep(200)
    val clusterService3 = node("server3").asInstanceOf[InternalNode].injector()
      .getInstance(classOf[ClusterService])
    clusterHealth = indexer("server1").health_prepare().setWaitForGreenStatus().setWaitForNodes("3").setWaitForRelocatingShards(0).execute.actionGet
    clusterHealth.isTimedOut should equal (false)
    clusterHealth.getStatus should equal (ClusterHealthStatus.GREEN)
    clusterHealth.getRelocatingShards should equal (0)
    clusterHealth.getActiveShards should equal (22)
    clusterHealth.getActivePrimaryShards should equal (11)
    Thread.sleep(200)
    clusterState1 = clusterService1.state()
    routingNodeEntry1 = clusterState1.routingTable.indicesRouting.get(clusterState1.nodes().localNodeId())
    //    routingNodeEntry1.shardsWithState(STARTED).size, anyOf(equalTo(7) should equal (8))
    clusterState2 = clusterService2.state()
    routingNodeEntry2 = clusterState2.routingTable.indicesRouting.get(clusterState2.nodes().localNodeId())
    //    routingNodeEntry2.shardsWithState(STARTED).size, anyOf(equalTo(7) should equal (8))
    var clusterState3 = clusterService3.state()
    var routingNodeEntry3 = clusterState3.routingTable.indicesRouting.get(clusterState3.nodes().localNodeId())
    routingNodeEntry3.shardsWithState(STARTED).size should equal (7)
    routingNodeEntry1.shardsWithState(STARTED).size + routingNodeEntry2.shardsWithState(STARTED).size + routingNodeEntry3.shardsWithState(STARTED).size should equal (22)
    closeNode("server1")
    clusterHealth = indexer("server3").health_prepare().setWaitForGreenStatus().setWaitForNodes("2").setWaitForRelocatingShards(0).execute.actionGet
    clusterHealth.isTimedOut should equal (false)
    clusterHealth.getStatus should equal (ClusterHealthStatus.GREEN)
    clusterHealth.getRelocatingShards should equal (0)
    clusterHealth.getActiveShards should equal (22)
    clusterHealth.getActivePrimaryShards should equal (11)
    Thread.sleep(200)
    clusterState2 = clusterService2.state()
    routingNodeEntry2 = clusterState2.routingTable.indicesRouting.get(clusterState2.nodes().localNodeId())
    routingNodeEntry2.shardsWithState(STARTED).size should equal (11)
    clusterState3 = clusterService3.state()
    routingNodeEntry3 = clusterState3.routingTable.indicesRouting.get(clusterState3.nodes().localNodeId())
    routingNodeEntry3.shardsWithState(STARTED).size should equal (11)
    routingNodeEntry2.shardsWithState(STARTED).size + routingNodeEntry3.shardsWithState(STARTED).size should equal (22)
    val deleteIndexResponse = indexer("server2").deleteIndex(Seq(indexName))
    deleteIndexResponse.isAcknowledged should equal (true)
    pending //fixme: failing test
    Thread.sleep(500)
    clusterState2 = clusterService2.state()
    routingNodeEntry2 = clusterState2.routingTable.indicesRouting.get(clusterState2.nodes().localNodeId())
    routingNodeEntry2 should be(null)
    clusterState3 = clusterService3.state()
    routingNodeEntry3 = clusterState3.routingTable.indicesRouting.get(clusterState3.nodes().localNodeId())
    routingNodeEntry3 should be(null)
  }

   //fixme
 ignore("testIndexLifecycleActionsWith11Shards0Backup") {
    val settings = settingsBuilder
      .put("index.number_of_shards", 11)
      .put("index.number_of_replicas", 0)
      .put("cluster.routing.schedule", "20ms")
      .build()
    //logger.info("Starting server1")
    startNode("server1", settings)
    val clusterService1 = node("server1").asInstanceOf[InternalNode].injector()
      .getInstance(classOf[ClusterService])
    val createIndexResponse = indexer("server1").createIndex(indexName)
    createIndexResponse.isAcknowledged should equal (true)
    var clusterHealth = indexer("server1").waitForGreenStatus()
    clusterHealth.isTimedOut should equal (false)
    clusterHealth.getStatus should equal (ClusterHealthStatus.GREEN)
    clusterHealth.getRelocatingShards should equal (0)
    clusterHealth.getActiveShards should equal (11)
    clusterHealth.getActivePrimaryShards should equal (11)
    var clusterState1 = clusterService1.state()
    var routingNodeEntry1 = clusterState1.routingTable.indicesRouting.get(clusterState1.nodes().localNodeId())
    routingNodeEntry1.shardsWithState(STARTED).size should equal (11)
    //logger.info("Starting server2")
    startNode("server2", settings)
    Thread.sleep(200)
    clusterHealth = indexer("server1").health_prepare().setWaitForGreenStatus().setWaitForRelocatingShards(0).setWaitForNodes("2").execute.actionGet
    clusterHealth.isTimedOut should equal (false)
    clusterHealth.getStatus should equal (ClusterHealthStatus.GREEN)
    clusterHealth.getRelocatingShards should equal (0)
    clusterHealth.getActiveShards should equal (11)
    clusterHealth.getActivePrimaryShards should equal (11)
    Thread.sleep(200)
    val clusterService2 = node("server2").asInstanceOf[InternalNode].injector()
      .getInstance(classOf[ClusterService])
    clusterState1 = clusterService1.state()
    routingNodeEntry1 = clusterState1.routingTable.indicesRouting.get(clusterState1.nodes().localNodeId())
    Set(5, 6) should contain(routingNodeEntry1.shardsWithState(STARTED).size)
    var clusterState2 = clusterService2.state()
    var routingNodeEntry2 = clusterState2.routingTable.indicesRouting.get(clusterState2.nodes().localNodeId())
    Set(5, 6) should contain(routingNodeEntry2.shardsWithState(STARTED).size)
    //logger.info("Starting server3")
    startNode("server3")
    Thread.sleep(200)
    val clusterService3 = node("server3").asInstanceOf[InternalNode].injector()
      .getInstance(classOf[ClusterService])
    clusterHealth = indexer("server1").health_prepare().setWaitForGreenStatus().setWaitForRelocatingShards(0).setWaitForNodes("3").execute.actionGet
    clusterHealth.isTimedOut should equal (false)
    clusterHealth.getStatus should equal (ClusterHealthStatus.GREEN)
    clusterHealth.getRelocatingShards should equal (0)
    clusterHealth.getActiveShards should equal (11)
    clusterHealth.getActivePrimaryShards should equal (11)
    Thread.sleep(200)
    clusterState1 = clusterService1.state()
    routingNodeEntry1 = clusterState1.routingTable.indicesRouting.get(clusterState1.nodes().localNodeId())
    Set(3, 4, 5) should contain(routingNodeEntry1.shardsWithState(STARTED).size)
    clusterState2 = clusterService2.state()
    routingNodeEntry2 = clusterState2.routingTable.indicesRouting.get(clusterState2.nodes().localNodeId())
    Set(3, 4, 5) should contain(routingNodeEntry2.shardsWithState(STARTED).size)
    var clusterState3 = clusterService3.state()
    var routingNodeEntry3 = clusterState3.routingTable.indicesRouting.get(clusterState3.nodes().localNodeId())
    routingNodeEntry3.shardsWithState(STARTED).size should equal (3)
    routingNodeEntry1.shardsWithState(STARTED).size + routingNodeEntry2.shardsWithState(STARTED).size + routingNodeEntry3.shardsWithState(STARTED).size should equal (11)
    closeNode("server1")
    clusterHealth = indexer("server3").health_prepare().setWaitForGreenStatus().setWaitForNodes("2").setWaitForRelocatingShards(0).execute.actionGet
    clusterHealth.isTimedOut should equal (false)
    clusterHealth.getStatus should equal (ClusterHealthStatus.GREEN)
    clusterHealth.getRelocatingShards should equal (0)
    clusterHealth.getActiveShards should equal (11)
    clusterHealth.getActivePrimaryShards should equal (11)
    Thread.sleep(200)
    clusterState2 = clusterService2.state()
    routingNodeEntry2 = clusterState2.routingTable.indicesRouting.get(clusterState2.nodes().localNodeId())
    Set(5, 6) should contain(routingNodeEntry2.shardsWithState(STARTED).size)
    clusterState3 = clusterService3.state()
    routingNodeEntry3 = clusterState3.routingTable.indicesRouting.get(clusterState3.nodes().localNodeId())
    Set(5, 6) should contain(routingNodeEntry3.shardsWithState(STARTED).size)
    routingNodeEntry2.shardsWithState(STARTED).size + routingNodeEntry3.shardsWithState(STARTED).size should equal (11)
    val deleteIndexResponse = indexer("server2").deleteIndex(Seq(indexName))
    deleteIndexResponse.isAcknowledged should equal (true)
    pending //fixme: failing test
    Thread.sleep(500)
    clusterState2 = clusterService2.state()
    routingNodeEntry2 = clusterState2.routingTable.indicesRouting.get(clusterState2.nodes().localNodeId())
    routingNodeEntry2 should be(null)
    clusterState3 = clusterService3.state()
    routingNodeEntry3 = clusterState3.routingTable.indicesRouting.get(clusterState3.nodes().localNodeId())
    routingNodeEntry3 should be(null)
  }
}
